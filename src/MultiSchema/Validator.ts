import type {
	ValidationResult,
	ValidationError,
	ValidationWarning,
	NameResolver,
	RefResolver,
	DependencyGraph,
} from './types.js';
import type { SchemaRegistry } from './SchemaRegistry.js';

/**
 * Validator: Detects conflicts, missing refs, cycles, and unresolved schemas
 */
export class Validator {
	constructor(
		private registry: SchemaRegistry,
		private nameResolver: NameResolver,
		private refResolver: RefResolver,
		private depGraph: DependencyGraph,
	) {}

	/**
	 * Run all validations on the project
	 */
	validate(): ValidationResult {
		const errors: ValidationError[] = [];
		const warnings: ValidationWarning[] = [];

		// Check export name conflicts
		errors.push(...this.detectExportConflicts());

		// Check for missing refs (warnings, not errors)
		warnings.push(...this.detectMissingRefs());

		// Check for cycles (warnings, not errors; handled via lazy builders)
		warnings.push(...this.detectCycles());

		// Check for invalid schemas
		errors.push(...this.detectInvalidSchemas());

		return {
			valid: errors.length === 0,
			errors,
			warnings,
		};
	}

	/**
	 * Detect export name conflicts: multiple schemas with the same export name
	 */
	private detectExportConflicts(): ValidationError[] {
		const errors: ValidationError[] = [];
		const nameToIds = new Map<string, string[]>();

		// Get all entries and their export names
		for (const entry of this.registry.getAllEntries()) {
			const exportName = this.nameResolver.resolveExportName(entry.id);
			if (!nameToIds.has(exportName)) {
				nameToIds.set(exportName, []);
			}
			nameToIds.get(exportName)!.push(entry.id);
		}

		// Find conflicts
		for (const [exportName, schemaIds] of nameToIds) {
			if (schemaIds.length > 1) {
				errors.push({
					code: 'EXPORT_CONFLICT',
					message: `Export name conflict: "${exportName}" is generated by multiple schemas`,
					details: {
						exportName,
						affectedSchemaIds: schemaIds,
					},
				});
			}
		}

		return errors;
	}

	/**
	 * Detect missing refs: $refs that cannot be resolved
	 */
	private detectMissingRefs(): ValidationWarning[] {
		const warnings: ValidationWarning[] = [];
		const visitedRefs = new Set<string>();

		for (const entry of this.registry.getAllEntries()) {
			const refs = this.extractRefsFromSchema(entry.schema);
			for (const ref of refs) {
				// Avoid duplicate warnings
				const refKey = `${entry.id}:${ref}`;
				if (visitedRefs.has(refKey)) {
					continue;
				}
				visitedRefs.add(refKey);

				// Try to resolve
				const resolution = this.refResolver.resolve(ref, entry.id);
				if (!resolution) {
					warnings.push({
						code: 'MISSING_REF',
						message: `Unresolved $ref: "${ref}" in schema "${entry.id}"`,
						schemaId: entry.id,
						details: {
							ref,
							fromSchemaId: entry.id,
						},
					});
				}
			}
		}

		return warnings;
	}

	/**
	 * Detect cycles: SCCs in dependency graph (warnings, not errors)
	 */
	private detectCycles(): ValidationWarning[] {
		const warnings: ValidationWarning[] = [];

		// Cycles are stored in depGraph.cycles as SCCs
		for (const scc of this.depGraph.cycles) {
			if (scc.size > 1) {
				const cycleArray = Array.from(scc);
				warnings.push({
					code: 'CIRCULAR_REF',
					message: `Circular dependency detected: ${cycleArray.join(' → ')} → ${cycleArray[0]}`,
					details: {
						cycle: cycleArray,
					},
				});
			}
		}

		return warnings;
	}

	/**
	 * Detect invalid schemas: missing required properties, malformed schemas
	 */
	private detectInvalidSchemas(): ValidationError[] {
		const errors: ValidationError[] = [];

		for (const entry of this.registry.getAllEntries()) {
			// Check if schema is a valid object or boolean
			if (
				typeof entry.schema !== 'object' &&
				typeof entry.schema !== 'boolean'
			) {
				errors.push({
					code: 'INVALID_SCHEMA',
					message: `Invalid schema for "${entry.id}": must be an object or boolean`,
					schemaId: entry.id,
					details: {
						schemaType: typeof entry.schema,
					},
				});
				continue;
			}

			// Additional validation could go here
			// e.g., check for required type field, etc.
		}

		return errors;
	}

	/**
	 * Extract all $refs from a schema (recursive)
	 */
	private extractRefsFromSchema(
		schema: any,
		visited = new Set<any>(),
	): string[] {
		const refs: string[] = [];

		// Avoid infinite loops
		if (visited.has(schema)) {
			return refs;
		}
		visited.add(schema);

		if (typeof schema !== 'object' || schema === null) {
			return refs;
		}

		// Check for $ref
		if (typeof schema.$ref === 'string') {
			refs.push(schema.$ref);
		}

		// Recurse into properties
		if (schema.properties && typeof schema.properties === 'object') {
			for (const prop of Object.values(schema.properties)) {
				refs.push(...this.extractRefsFromSchema(prop, visited));
			}
		}

		// Recurse into items
		if (schema.items) {
			refs.push(...this.extractRefsFromSchema(schema.items, visited));
		}

		// Recurse into allOf, anyOf, oneOf
		for (const key of ['allOf', 'anyOf', 'oneOf']) {
			if (Array.isArray(schema[key])) {
				for (const item of schema[key]) {
					refs.push(...this.extractRefsFromSchema(item, visited));
				}
			}
		}

		// Recurse into additionalProperties
		if (
			schema.additionalProperties &&
			typeof schema.additionalProperties === 'object'
		) {
			refs.push(
				...this.extractRefsFromSchema(schema.additionalProperties, visited),
			);
		}

		return refs;
	}
}
